{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-da15bb488e38e105b73aac379f3470f4ab3051f0",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/RainyDayFund.sol": "project/contracts/RainyDayFund.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/RainyDayFund.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.28;\r\n\r\n// Interface for USDC (ERC20) token\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n}\r\n\r\ncontract RainyDayFund {\r\n    // Maximum gas per transaction (adjust based on network conditions)\r\n    uint256 public constant MAX_GAS_PER_BATCH = 5000000; // ~5M gas limit\r\n\r\n    // USDC contract\r\n    IERC20 public immutable usdc;\r\n\r\n    // Owner of the contract\r\n    address public owner;\r\n\r\n    // Total risk pool balance in USDC\r\n    uint256 public riskPoolBalance;\r\n\r\n    // Investor funds tracked separately\r\n    uint256 public totalInvestorFunds;\r\n\r\n    // Token counter for unique policy IDs\r\n    uint256 private tokenCounter;\r\n\r\n    // Array to track users for payouts\r\n    address[] private allFarmers;\r\n    mapping(address => bool) private isFarmer;\r\n\r\n    // Last processed tokenId (monotonic)\r\n    uint256 public lastProcessedTokenId;\r\n\r\n    // Resume indices for batch processing\r\n    uint256 public lastFarmerIndex;\r\n    uint256 public lastTokenIndex;\r\n\r\n    // Policy types\r\n    enum PolicyType {\r\n        BASIC,      // 100 USDC premium\r\n        STANDARD,   // 250 USDC premium  \r\n        PREMIUM     // 500 USDC premium\r\n    }\r\n\r\n    // Policy pricing (USDC - 6 decimals)\r\n    mapping(PolicyType => uint256) public premiums;\r\n\r\n    // Mapping for policies by tokenId (one policy per token)\r\n    struct Policy {\r\n        uint256 creationTimestamp;\r\n        uint256 expirationTimestamp;\r\n        uint256 payoutAmount;\r\n        bytes32 locationHash;        // hashed location\r\n        uint256 weatherData;         // fetched weather data (e.g., rainfall)\r\n        bool weatherDataFetched;     // weather data is available\r\n        bool payoutDone;             // payout already occurred\r\n    }\r\n    mapping(uint256 => Policy) public policies; // tokenId => Policy\r\n\r\n    // Token ownership\r\n    mapping(uint256 => address) public tokenOwner; // tokenId => owner\r\n    mapping(address => uint256[]) public farmerTokens; // farmer => tokenIds\r\n\r\n    // Investment tracking\r\n    mapping(address => uint256) public investorShares; // investor => pool share\r\n\r\n    // Events\r\n    event PolicyBoughtEvent(\r\n        address indexed farmer,\r\n        uint256 indexed tokenId,\r\n        PolicyType policyType,\r\n        uint256 premium,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event InvestmentMadeEvent(\r\n        address indexed investor,\r\n        uint256 amount,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event InvestmentWithdrawnEvent(\r\n        address indexed investor,\r\n        uint256 amount,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event FarmerAdded(address indexed farmer, uint256 timestamp);\r\n    event FarmerRemoved(address indexed farmer, uint256 timestamp);\r\n\r\n    event BatchProcessingStarted(uint256 maxProcess, uint256 timestamp);\r\n    event BatchProcessingCompleted(uint256 processed, uint256 gasUsed, uint256 timestamp);\r\n\r\n    // Modifiers\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Only owner\");\r\n        _;\r\n    }\r\n\r\n    modifier validPolicyType(PolicyType _policyType) {\r\n        require(uint8(_policyType) <= 2, \"Invalid policy type\");\r\n        _;\r\n    }\r\n\r\n    constructor(address _usdcAddress) {\r\n        owner = msg.sender;\r\n        usdc = IERC20(_usdcAddress);\r\n        tokenCounter = 1;\r\n        lastProcessedTokenId = 0;\r\n        lastFarmerIndex = 0;\r\n        lastTokenIndex = 0;\r\n\r\n        // Set premiums\r\n        premiums[PolicyType.BASIC] = 100 * 10**6;\r\n        premiums[PolicyType.STANDARD] = 250 * 10**6;\r\n        premiums[PolicyType.PREMIUM] = 500 * 10**6;\r\n    }\r\n\r\n    /**\r\n     * @dev Farmers buy policies\r\n     */\r\n    function buyPolicy(PolicyType _policyType) external validPolicyType(_policyType) returns (uint256 tokenId) {\r\n        uint256 premiumAmount = premiums[_policyType];\r\n        require(usdc.balanceOf(msg.sender) >= premiumAmount, \"Insufficient USDC balance\");\r\n        require(usdc.allowance(msg.sender, address(this)) >= premiumAmount, \"Allowance too low\");\r\n\r\n        require(usdc.transferFrom(msg.sender, address(this), premiumAmount), \"Transfer failed\");\r\n\r\n        tokenId = tokenCounter++;\r\n        tokenOwner[tokenId] = msg.sender;\r\n        farmerTokens[msg.sender].push(tokenId);\r\n\r\n        if (!isFarmer[msg.sender]) {\r\n            isFarmer[msg.sender] = true;\r\n            allFarmers.push(msg.sender);\r\n            emit FarmerAdded(msg.sender, block.timestamp);\r\n        }\r\n\r\n        policies[tokenId] = Policy({\r\n            creationTimestamp: block.timestamp,\r\n            expirationTimestamp: block.timestamp + 30 days,\r\n            payoutAmount: premiumAmount * 2,\r\n            locationHash: keccak256(abi.encodePacked(msg.sender, tokenId)),\r\n            weatherData: 0,\r\n            weatherDataFetched: false,\r\n            payoutDone: false\r\n        });\r\n\r\n        riskPoolBalance += premiumAmount;\r\n\r\n        emit PolicyBoughtEvent(msg.sender, tokenId, _policyType, premiumAmount, block.timestamp);\r\n\r\n        return tokenId;\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a farmer from allFarmers if they have no active tokens.\r\n     */\r\n    function _removeFarmer(address farmer) internal {\r\n        if (farmerTokens[farmer].length == 0 && isFarmer[farmer]) {\r\n            isFarmer[farmer] = false;\r\n\r\n            // Find and remove from array\r\n            uint256 len = allFarmers.length;\r\n            for (uint256 i = 0; i < len; i++) {\r\n                if (allFarmers[i] == farmer) {\r\n                    allFarmers[i] = allFarmers[len - 1];\r\n                    allFarmers.pop();\r\n                    break;\r\n                }\r\n            }\r\n\r\n            emit FarmerRemoved(farmer, block.timestamp);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Batch payout\r\n     */\r\n    function batchPayout(uint256 _maxProcess, uint256 _gasBuffer) external onlyOwner {\r\n        require(_gasBuffer < 1000000, \"Gas buffer too large\");\r\n\r\n        uint256 startGas = gasleft();\r\n        uint256 gasBuffer = _gasBuffer > 0 ? _gasBuffer : 200000;\r\n        uint256 maxProcess = _maxProcess > 0 ? _maxProcess :\r\n                            (MIN(MAX_GAS_PER_BATCH - gasBuffer, gasleft() - gasBuffer) / 50000);\r\n\r\n        emit BatchProcessingStarted(maxProcess, block.timestamp);\r\n\r\n        uint256 processed = 0;\r\n        uint256 farmersLength = allFarmers.length;\r\n\r\n        uint256 i = lastFarmerIndex;\r\n        uint256 j = lastTokenIndex;\r\n\r\n        uint256 gasUsed = 0;\r\n\r\n        for (; i < farmersLength && processed < maxProcess; ) {\r\n            address farmer = allFarmers[i];\r\n            uint256[] storage tokens = farmerTokens[farmer];\r\n            uint256 tokensLength = tokens.length;\r\n\r\n            for (; j < tokensLength && processed < maxProcess; ) {\r\n                uint256 tokenId = tokens[j];\r\n\r\n                if (tokenId > lastProcessedTokenId) {\r\n                    Policy storage policy = policies[tokenId];\r\n\r\n                    if (!policy.payoutDone &&\r\n                        policy.weatherDataFetched &&\r\n                        block.timestamp > policy.expirationTimestamp &&\r\n                        checkChainLink(tokenId) &&\r\n                        policy.weatherData < 10) {\r\n\r\n                        if (riskPoolBalance >= policy.payoutAmount) {\r\n                            require(usdc.transfer(farmer, policy.payoutAmount), \"Transfer failed\");\r\n                            riskPoolBalance -= policy.payoutAmount;\r\n                            policy.payoutDone = true;\r\n                            processed++;\r\n                            lastProcessedTokenId = tokenId;\r\n\r\n                            // Remove token from farmer's list\r\n                            tokens[j] = tokens[tokensLength - 1];\r\n                            tokens.pop();\r\n                            tokensLength--;\r\n\r\n                            // Cleanup farmer if no tokens remain\r\n                            if (tokensLength == 0) {\r\n                                _removeFarmer(farmer);\r\n                            }\r\n\r\n                            continue; // recheck current j (new token swapped in)\r\n                        } else {\r\n                            revert(\"Insufficient funds in risk pool\");\r\n                        }\r\n                    }\r\n                }\r\n\r\n                j++;\r\n\r\n                if (gasleft() < gasBuffer) {\r\n                    lastFarmerIndex = i;\r\n                    lastTokenIndex = j;\r\n                    gasUsed = startGas - gasleft();\r\n                    emit BatchProcessingCompleted(processed, gasUsed, block.timestamp);\r\n                    return;\r\n                }\r\n            }\r\n\r\n            i++;\r\n            j = 0;\r\n        }\r\n\r\n        lastFarmerIndex = 0;\r\n        lastTokenIndex = 0;\r\n        gasUsed = startGas - gasleft();\r\n        emit BatchProcessingCompleted(processed, gasUsed, block.timestamp);\r\n    }\r\n\r\n    function resetBatchProcessing() external onlyOwner {\r\n        lastProcessedTokenId = 0;\r\n        lastFarmerIndex = 0;\r\n        lastTokenIndex = 0;\r\n    }\r\n\r\n    function getBatchStatus() external view returns (uint256 lastProcessed, uint256 remainingTokens, uint256 resumeFarmerIndex, uint256 resumeTokenIndex) {\r\n        uint256 totalTokens = tokenCounter - 1;\r\n        uint256 processed = lastProcessedTokenId;\r\n        uint256 remaining = totalTokens > processed ? (totalTokens - processed) : 0;\r\n        return (processed, remaining, lastFarmerIndex, lastTokenIndex);\r\n    }\r\n\r\n    function MIN(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function checkChainLink(uint256 _tokenId) internal view returns (bool conditionMet) {\r\n        return ((block.timestamp + _tokenId) % 2) == 0;\r\n    }\r\n\r\n    function updateWeatherData(uint256 _tokenId, uint256 _rainfall) external onlyOwner {\r\n        Policy storage policy = policies[_tokenId];\r\n        require(policy.creationTimestamp != 0, \"Policy not found\");\r\n        require(!policy.weatherDataFetched, \"Already fetched\");\r\n        policy.weatherData = _rainfall;\r\n        policy.weatherDataFetched = true;\r\n    }\r\n\r\n    function payout(uint256 _tokenId) external {\r\n        Policy storage policy = policies[_tokenId];\r\n        address policyHolder = tokenOwner[_tokenId];\r\n\r\n        require(policy.creationTimestamp != 0, \"Policy not found\");\r\n        require(block.timestamp > policy.expirationTimestamp, \"Crop season not over\");\r\n        require(policy.weatherDataFetched, \"Weather data not available\");\r\n        require(!policy.payoutDone, \"Already paid\");\r\n        require(checkChainLink(_tokenId), \"Weather condition not met\");\r\n        require(riskPoolBalance >= policy.payoutAmount, \"Insufficient pool funds\");\r\n\r\n        if (policy.weatherData < 10) {\r\n            require(usdc.transfer(policyHolder, policy.payoutAmount), \"USDC payout failed\");\r\n            riskPoolBalance -= policy.payoutAmount;\r\n            policy.payoutDone = true;\r\n\r\n            // Remove token from farmer\r\n            uint256[] storage tokens = farmerTokens[policyHolder];\r\n            for (uint256 i = 0; i < tokens.length; i++) {\r\n                if (tokens[i] == _tokenId) {\r\n                    tokens[i] = tokens[tokens.length - 1];\r\n                    tokens.pop();\r\n                    break;\r\n                }\r\n            }\r\n            if (tokens.length == 0) {\r\n                _removeFarmer(policyHolder);\r\n            }\r\n        }\r\n    }\r\n\r\n    // ---------------- Investor logic ----------------\r\n\r\n    function invest(uint256 _amount) external {\r\n        require(_amount > 0, \"Investment amount must be greater than 0\");\r\n        require(usdc.balanceOf(msg.sender) >= _amount, \"Insufficient USDC balance\");\r\n        require(usdc.allowance(msg.sender, address(this)) >= _amount, \"Insufficient USDC allowance\");\r\n        require(usdc.transferFrom(msg.sender, address(this), _amount), \"USDC transfer failed\");\r\n\r\n        investorShares[msg.sender] += _amount;\r\n        totalInvestorFunds += _amount;\r\n        riskPoolBalance += _amount;\r\n\r\n        emit InvestmentMadeEvent(msg.sender, _amount, block.timestamp);\r\n    }\r\n\r\n    function withdrawInvestment(uint256 _shareAmount) external {\r\n        uint256 investorShare = investorShares[msg.sender];\r\n        require(investorShare >= _shareAmount && _shareAmount > 0, \"Invalid share amount\");\r\n\r\n        // Calculate proportional withdrawal from the pool\r\n        uint256 withdrawAmount = (_shareAmount * riskPoolBalance) / totalInvestorFunds;\r\n\r\n        investorShares[msg.sender] -= _shareAmount;\r\n        totalInvestorFunds -= _shareAmount;\r\n        riskPoolBalance -= withdrawAmount;\r\n\r\n        require(usdc.transfer(msg.sender, withdrawAmount), \"USDC withdrawal failed\");\r\n\r\n        emit InvestmentWithdrawnEvent(msg.sender, withdrawAmount, block.timestamp);\r\n    }\r\n\r\n    // ---------------- Getters ----------------\r\n\r\n    function getFarmerTokens(address _farmer) external view returns (uint256[] memory) {\r\n        return farmerTokens[_farmer];\r\n    }\r\n\r\n    function getPolicyPricing(PolicyType _policyType) external view validPolicyType(_policyType) returns (uint256 premium) {\r\n        return premiums[_policyType];\r\n    }\r\n\r\n    function tokenExists(uint256 _tokenId) external view returns (bool) {\r\n        return tokenOwner[_tokenId] != address(0);\r\n    }\r\n\r\n    function ownerOf(uint256 _tokenId) external view returns (address) {\r\n        require(tokenOwner[_tokenId] != address(0), \"Token does not exist\");\r\n        return tokenOwner[_tokenId];\r\n    }\r\n\r\n    function getTotalPolicies() external view returns (uint256) {\r\n        return tokenCounter - 1;\r\n    }\r\n\r\n    function getContractUSDCBalance() external view returns (uint256) {\r\n        return usdc.balanceOf(address(this));\r\n    }\r\n\r\n    function getUserInvestments(address _investor) external view returns (uint256) {\r\n        return investorShares[_investor];\r\n    }\r\n\r\n    function getUSDCAddress() external view returns (address) {\r\n        return address(usdc);\r\n    }\r\n}\r\n"
      }
    }
  }
}